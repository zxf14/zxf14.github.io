[{"title":"视频直播","date":"2017-05-05T06:18:58.000Z","path":"2017/05/05/视频直播/","text":"参考资料：H5视频直播扫盲| AlloyTeamH5直播起航| Aotu.io「凹凸实验室」HTTP Live Streaming | wiki 视频直播分类 HLS RTMP HTTP Live Streaming Real Time Messaging Protocol 由苹果公司提出的基于HTTP的流媒体网络传输协议 Macromedia 开发的一套视频直播协议，现在属于 Adobe。这套方案需要搭建专门的 RTMP 流媒体服务如 Adobe Media Server，并且在浏览器中只能使用 Flash 实现播放器 原理：整个流分成一个个小的文件来下载 每个时刻的数据收到后立即发送 延时高，跨平台 延迟低、实时性较好，无法支持移动端 WEB 播放 移动web端 PC端 提供HLS的服务器 以 H.263 格式对图像进行编码，以 MP3 或者 HE-AAC 对声音进行编码，最终打包到 MPEG-2 TS（Transport Stream）容器之中 分割：把编码好的 TS 文件等长切分成后缀为 ts 的小文件，并生成一个 .m3u8 的纯文本索引文件； 客户端 在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。 m3u8 就是包含多个 ts 文件的播放列表 m3u8 必须动态更新，ts 可以走 CDN","tags":[]},{"title":"git-flow的使用","date":"2017-04-08T14:37:11.000Z","path":"2017/04/08/git-flow的使用/","text":"简介问题：在多人协作开发过程中，常常使用git做版本控制，但是大型项目的部署版本，开发版本之间关系复杂，有时需要在部署后发现了bug，又需要一系列的补救过程，往往会导致版本更加难以管理，需要谨慎细致的操作。在成员开发过程中，也会因为代码冲突代码覆盖等问题导致浪费时间的返工。这些都是缺乏合理的开发活动控制情况下发生的问题。合理的开发模型是重要且必须的。 理解：简单来说就是一套软件开发活动模型，是软件开发最佳实践。对git命令包装并合理组织，简化了部分git操作。 特色：通过利用Git创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离 目标：重点解决由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。 在开始研究Git Flow的具体内容前，下面这张图可以看到模型的全貌（引自nvie的博文)： 参考资料参考博客官方github仓库中文介绍说明 使用说明安装brew install git-flow 初始化在项目目录下$ git flow init这条指令只是初始化了一个空的 git 项目，创建了新的分支。如果查看项目分支情况，可以看到默认分支变成develop分支，所以接下来都会用git push origin develop将代码push到仓库里。123$ git branch* develop master Feature branchesFeature分支用来同时开发不同的产品功能。以authentication为例 开始开发功能就像这个输出说明的一样，这个指令从develop分支拉了一个分支，而且将当前开发分支转为这个分支。12345678910$ git flow feature start authenticationSwitched to a new branch &apos;feature/authentication&apos;Summary of actions:- A new branch &apos;feature/authentication&apos; was created, based on &apos;develop&apos;- You are now on branch &apos;feature/authentication&apos;Now, start committing on your feature. When done, use: git flow feature finish authentication 功能开发完成将分支用git merge --no-ff feature/authentication指令来将分支合并到develop分支，移除当前功能分支，切换工作区到develop分支1234567891011121314$ git flow feature finish authenticationSwitched to branch &apos;develop&apos;Updating 9060376..00bafe4Fast-forward authentication.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 authentication.txtDeleted branch feature/authentication (was 00bafe4).Summary of actions:- The feature branch &apos;feature/authentication&apos; was merged into &apos;develop&apos;- Feature branch &apos;feature/authentication&apos; has been removed- You are now on branch &apos;develop&apos;Your feature branch will be merged and you&apos;re taken back to your develop branch. Internally, git-flow used git merge --no-ff feature/authentication to make sure you don&apos;t lose any hostorical information about your feature branch before it is removed. Versioned releasesrelease分支是为发布新的产品版本而设计的。在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在release分支上进行这些工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。123456789101112$ git flow release start 0.1.0Switched to a new branch &apos;release/0.1.0&apos;Summary of actions:- A new branch &apos;release/0.1.0&apos; was created, based on &apos;develop&apos;- You are now on branch &apos;release/0.1.0&apos;Follow-up actions:- Bump the version number now!- Start committing last-minute fixes in preparing your release- When done, run: git flow release finish &apos;0.1.0&apos; finish后在master分支，所以可以部署了1234567891011121314$ git flow release finish 0.1.0Switched to branch &apos;master&apos;Merge made by the &apos;recursive&apos; strategy. authentication.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 authentication.txtDeleted branch release/0.1.0 (was 1b26f7c).Summary of actions:- Latest objects have been fetched from &apos;origin&apos;- Release branch has been merged into &apos;master&apos;- The release was tagged &apos;0.1.0&apos;- Release branch has been back-merged into &apos;develop&apos;- Release branch &apos;release/0.1.0&apos; has been deleted Hotfixing production codeBecause you keep your master branch always in sync with the code that’s on production, you’ll be able to quickly fix any issues on production.因为master分支总是和产品代码同步，所以可以快速修复产品问题。例如，产品没有加载配置，你将会回退部署，然后开始一个hotfix分支12345678910111213$ git flow hotfix start assetsSwitched to a new branch &apos;hotfix/assets&apos;Summary of actions:- A new branch &apos;hotfix/assets&apos; was created, based on &apos;master&apos;- You are now on branch &apos;hotfix/assets&apos;Follow-up actions:- Bump the version number now!- Start committing your hot fixes- When done, run: git flow hotfix finish &apos;assets&apos; Hotfix分支很像release分支，除了一个是基于master一个基于develop。12345678910111213141516171819 $ git flow hotfix finish assetsSwitched to branch &apos;master&apos;Merge made by the &apos;recursive&apos; strategy. assets.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 assets.txtSwitched to branch &apos;develop&apos;Merge made by the &apos;recursive&apos; strategy. assets.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 assets.txtDeleted branch hotfix/assets (was 08edb94).Summary of actions:- Latest objects have been fetched from &apos;origin&apos;- Hotfix branch has been merged into &apos;master&apos;- The hotfix was tagged &apos;0.1.1&apos;- Hotfix branch has been back-merged into &apos;develop&apos;- Hotfix branch &apos;hotfix/assets&apos; has been deleted 不用git-flow的理由不用做版本发布，就不需要用。","tags":[{"name":"git","slug":"git","permalink":"https://zxf14.github.io/tags/git/"}]},{"title":"前端面试记录","date":"2017-04-07T04:40:05.000Z","path":"2017/04/07/面试经验积累/","text":"腾讯笔试对于网络的考察非常多，也是这方面细节了解不够，应该开始计划对于这方面系统的复习。 编程题一道很基础，统计数组里数字出现的次数。 还有一道是找规律的题目。1的拆分方式为02的拆分方式为03=2+1的拆分方式为14=3+1=2+2=2+1+1拆分结果为35=4+1=3+2=3+1+1=2+2+1=2+1+1+1+1拆分结果为5种6=5+1=4+2=4+1+1=3+2+1=3+1+1+1=2+2+1+1+1=2+1+1+1+1+1拆分结果为7种并没有明白这个规律是什么。为什么6不能分为3+3，因为必须有1或者2？为什么可以分为2+2不能分为1+1？ 阿里笔试实现模版字符串的变量替换。实现render方法。1234567891011let greeting = &apos;My name is $&#123;name&#125;, age $&#123;age&#125;, I am a $&#123;job.jobName&#125;&apos;;let employee = &#123; name: &apos;XiaoMing&apos;, age: 11, job: &#123; jobName: &apos;designer&apos;, jobLevel: &apos;senior&apos; &#125;&#125;;let result = greeting.render(employee);console.log(result); //My name is XiaoMing, age 11, I am a designer 题目其实很简单。但是考察的点还是很多的。 对象属性的获取 正则表达式 字符串方法 上下文 正则表达式很不熟悉，所以花了很长时间还没做完。sad 源码附上123456789101112131415161718192021222324252627282930313233343536String.prototype.render=function(objToReplace)&#123; // 正则表达式捕获字符串中的变量部分 const pattern= /(\\$\\&#123;[^\\$\\&#123;\\&#125;]*\\&#125;)/; const patternG= /(\\$\\&#123;[^\\$\\&#123;\\&#125;]*\\&#125;)/g; let result=this; let varList=result.match(patternG);//[&apos;$&#123;name&#125;&apos;,&apos;$&#123;age&#125;&apos;,&apos;$&#123;job.jobName&#125;&apos;] for (let varName of varList)&#123; // 获取变量名 varName=varName.slice(2,-1); let propVal; // 嵌套取值 if(varName.indexOf(&apos;.&apos;)!==-1)&#123; let objAndProp=varName.split(&apos;.&apos;); let obj=getPropertyValue.call(objToReplace,objAndProp[0]); propVal=getPropertyValue.call(obj,objAndProp[1]); &#125; // 直接取值 else&#123; propVal=getPropertyValue.call(objToReplace,varName); &#125; result=result.replace(pattern,propVal); &#125; return result;&#125;function getPropertyValue(prop)&#123; let keys=Object.keys(this); for (let key of keys)&#123; if(prop===key)&#123; return this[prop]; &#125; &#125; return null;&#125; 阿里面试一面面试官主要就是让我介绍自己的项目以及学习过程。然后问到es6语法，html5，哪个方面比较擅长，兼容性，性能优化。最后他说，建议学习深度需要加深。没有问框架，以及原理之类的，他说觉得前端变化很快，问这些问题也会有的人答不出来。","tags":[]},{"title":"dva初体验","date":"2017-03-31T07:12:53.000Z","path":"2017/03/31/dva初体验/","text":"考完试来填坑","tags":[]},{"title":"node中间件的实现原理","date":"2017-03-31T07:12:43.000Z","path":"2017/03/31/node中间件的实现原理/","text":"考完试来填坑","tags":[]},{"title":"怎样在react+redux的开发过程减少样板代码","date":"2017-03-31T07:11:53.000Z","path":"2017/03/31/怎样在react-redux的开发过程减少样板代码/","text":"考完试来填坑","tags":[]},{"title":"thunk、saga，promise的比较","date":"2017-03-31T07:11:12.000Z","path":"2017/03/31/thunk、saga，promise的比较/","text":"考完试来填坑哎如果学这些就是为了学api就太可惜了所以学完api要赶紧了解认识一下区别","tags":[]},{"title":"个人摄影图片展示应用开发记录","date":"2017-03-28T06:47:27.000Z","path":"2017/03/28/个人摄影图片展示应用开发记录/","text":"##配置七牛 SDK 注册账号https://www.qiniu.com/ 创建存储空间pxgallary http://cn.vuejs.org/v2/guide/computed.html","tags":[{"name":"javascript vue","slug":"javascript-vue","permalink":"https://zxf14.github.io/tags/javascript-vue/"}]},{"title":"markdown->html","date":"2017-03-27T14:36:41.000Z","path":"2017/03/27/markdown-html/","text":"MD =&gt; HTML原理参考：https://github.com/jaywcjlove/MDEditor 基本过程 词法解析器：Lexer将原的输入解析输出token序列 使用正则表达式将内容提取出来作为一个token存到数组中 token是一个类似这样的对象var token1={type:&quot;space&quot;} , token2={type:&#39;head&#39;,text:&quot;abcdefg&quot;} 在编译原理中，应该构造有限状态自动机来判断。但是我们有正则表达式这个工具就不要麻烦了 语法解析器：Parser将token序列生成抽象语法树（AST） 提取token并根据不同的类型对内容进行包装，生成html 将得到的html显示在界面上innerHtml 问题：这里其实存在一个回溯问题，比如多个列表项，则需要在头尾加上ul标签。在编译过程其实应该制定语法规则，以及对冲突项列出优先级次序，然后进行解析。因为这里都很简单，没有很多语法规则，所以只需要在一开始识别出整个列表，而不是单个列表项。再次解析列表时，识别其中的列表项。","tags":[]},{"title":"js原型链、instanceof和继承","date":"2017-03-23T14:47:08.000Z","path":"2017/03/23/js原型链、instanceof和继承/","text":"参考：MDN：instanceofMDN：Inheritance and the prototype chain理解JavaScript的原型链和继承 new实现了什么操作new的过程发生了什么？ 123456789function A(name)&#123; this.name = name&#125;var a = new A('hehe') // var a = new A('hehe') =&gt; var a = new Object(); a.__proto__ = A.prototype; A.call(a, 'hehe'); 原型链和prototype属性原型链是什么上面的 __proto__ 是什么？就是原型链，原型链是内部 [ [Prototype ]]，指向它“父类”的prototype。 打开浏览器控制台，可以看到函数变量都有一个prototype属性（箭头函数没有）。通过这一句a.__proto__ = A.prototype; 说明a的原型链就是指向函数A的prototype属性。 这里就有一个重要的认识了，虽然名字很像，但是原型链并不是prototype属性，同时原型链指向“父类”的prototype。几乎所有对象都有原型链（除了null和undefined），通过__proto__可以看到原型链指向什么（当然最好使用 Object.getPrototypeOf 取原型链） 通过实验可以发现，js中对象的链可以非常复杂。一图胜千言。这里借一张图。 简而言之 函数对象，Function，Object，Array等等的原型链都指向Function.prototype 通过new操作符创建的对象原型链指向原来的函数的prototype属性 Object.prototype属性的原型链指向null（到null就停止了） 而Function.prototype（Array，Date，String等等），以及函数对象的prototype，原型链都指向Object.prototype prototype属性究竟是什么呢可以看到是一个Object，有constructor和原型链。constructor是一个函数，也就是函数自身。这可以为后面提到的继承做准备。 instanceof什么意思 The instanceof operator tests whether an object has in its prototype chain the prototype property of a constructor. Syntax：object instanceof constructor 意思就是object.__proto__===constructor.prototype MDN的教程中举例12345// defining constructorsfunction C() &#123;&#125;var o = new C();// true, because: Object.getPrototypeOf(o) === C.prototypeo instanceof C; 但是 1234var simpleStr = &apos;This is a simple string&apos;; var myString = new String();simpleStr instanceof String; // returns false, checks the prototype chain, finds undefined 可是在浏览器中试验Object.getPrototypeOf(simpleStr) === String.prototype结果是true，大概这算作一个特殊情况 修正：这里是因为string字面量属于primitive类型，应该使用typeof，instanceof用于检测引用类型， 如何实现继承https://babeljs.io/repl/可以在这个网站在线编译并查看结果 12345678910111213class A&#123; constructor(name) &#123; this.name= name &#125; toString() &#123; return this.name &#125;&#125;class B extends A &#123; toString()&#123; return this.name + &apos;b&apos; &#125;&#125; 编译出来的ES5继承 123456789101112131415161718192021222324function _inherits(subClass, superClass) &#123; subClass.prototype.__proto__=superClass.prototype;&#125;var A = (function () &#123; function A(name) &#123; this.name = name; &#125; A.prototype.toString = function toString() &#123; return this.name; &#125;; return A;&#125;)();var B = (function (_A) &#123; function B() &#123; if (_A != null) &#123; _A.apply(this, arguments); &#125; &#125; _inherits(B, _A); B.prototype.toString = function toString() &#123; return this.name + 'b'; &#125;; return B;&#125;)(A); 简单来说就是这样","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxf14.github.io/tags/JavaScript/"}]},{"title":"springmvc源码","date":"2017-03-23T14:45:57.000Z","path":"2017/03/23/springmvc源码/","text":"DispatcherServlet来看spring mvc请求处理过程架构官方架构图可以看到请求处理过程，而DispatcherServlet正是担当front controller的角色。 生命周期通过源码可以看到，DispatcherServlet继承自FrameworkServlet，FrameworkServlet继承HttpServletBean，HttpServletBean继承HttpServlet。而Servlet生命周期的三个阶段就是【init-service-destroy】所以对DispatcherServlet而言，类似最初进行servlet编程。继承HttpServlet，重写doGet、doPost，在方法中跳转到jsp页面，利用注解或者在xml文件中注册Servlet。 初始化在HttpServletBean中，覆写了HttpServlet类的init()方法。前面是将web.xml中在DispatcherServlet这个Servlet下面的&lt;init-param&gt;配置元素利用JavaBean的方式（即通过setter方法）读取到DispatcherServlet中来值得一提的是其中有一句1initServletBean(); 但是在HttpServletBean中是一个空方法，留给子类来实现，这就是模版方法，在父类中定义执行流程，把可变的部分留给子类实现。体现了开闭原则。 initServletBean在FrameworkServlet中关键的一句1this.webApplicationContext = initWebApplicationContext(); 所以FrameworkServlet存在的意义也用来抽离出建立 WebApplicationContext 上下文这个过程的。建立一个和Servlet关联的Spring容器上下文，并将其注册到ServletContext中。 因为DispatcherServlet重写了onRefresh，建立上下文后，通过onRefresh(ApplicationContext context)方法的回调，进入到DispatcherServlet类onRefresh方法中initStrategies()封装了初始化策略以detectAllHandlerMappings为例，detectAllHandlerMappings默认为true，把上下文中所有HandlerMapping类型的Bean都注册在handlerMappings这个List变量中。 总结：HttpServletBean完成的是&lt;init-param&gt;配置元素的依赖注入，FrameworkServlet完成的是容器上下文的建立，DispatcherServlet完成的是SpringMVC具体编程元素的初始化策略。 Service以Get请求为例，经过HttpServlet基类中service()方法的委派，请求会被转发到doGet()方法中。doGet()方法，在DispatcherServlet的父类FrameworkServlet类中被重写。封装了processRequest方法，关键就是doService(request, response);前一部分是将当前请求的Locale对象和属性，分别设置到LocaleContextHolder和RequestContextHolder这两个抽象类中的ThreadLocal对象中，也就是分别将这两个东西和请求线程做了绑定。在doService()处理结束后，再恢复回请求前的LocaleContextHolder和RequestContextHolder，也即解除线程绑定。每次请求处理结束后，容器上下文都发布了一个ServletRequestHandledEvent事件，你可以注册监听器来监听该事件。 只是做了一些线程安全的隔离。 doService又是一个抽象方法。子类实现。实现在DispatcherServlet中doDispatch(request, response);几个requet.setAttribute()方法的调用，将前面在初始化流程中实例化的对象设置到http请求的属性中，供下一步处理使用，其中有容器的上下文对象、本地化解析器等SpringMVC特有的编程元素。 doDispatch中 mappedHandler = getHandler(processedRequest);获得处理请求的handler，返回HandlerExecutionChainHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());获得处理请求的handler adaptermappedHandler.applyPreHandle(processedRequest, response执行interceptor的prehandle方法mv = ha.handle(processedRequest, response, mappedHandler.getHandler());实际调用handler，返回ModelAndViewapplyDefaultViewName(processedRequest, mv);设置view的名字 mappedHandler.applyPostHandle(processedRequest, response, mv);执行intercepter的postHandle方法，processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);发送结果 数据结构HandlerMapping、HandlerAdapter、View这些接口的设计。HandlerAdapter：是一个接口。support方法根据类型来判断该adapter是否支持handler实例，handle方法用给定的handler处理请求；1234567public interface HandlerAdapter &#123; boolean supports(Object handler); ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; long getLastModified(HttpServletRequest request, Object handler);&#125; HandlerMapping接口中：getHandler获取请求的handler和所有interceptors，返回HandlerExecutionChain的对象123456public interface HandlerMapping &#123; String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.pathWithinHandlerMapping&quot;; String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingPattern&quot;; String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &quot;.introspectTypeLevelMapping&quot;; //... HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception; View接口：主要是render方法 void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception; HandlerExecutionChain：主要包含 interceptors的list，和一个handle，这里handler是由Object对象来引用的，没有绑定任何接口，这里说明了任何对象都可以作为最后的处理对象来生成视图ModelAndView是处理的结果，主要包含Object引用的view，和ModelMap引用的model。view可以是view名（String）或者是一个view的实例。ModelMap继承LinkedHashMap，也就是一个map，放了属性名和属性值。 HandlerInterceptor这个接口，定义了拦截器的实现preHandle，postHandle，afterCompletion就像刚刚在doDispatch中一样，环绕着hanlder实现,分别在handler执行前，执行后和渲染后执行。123456public interface HandlerInterceptor &#123; boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)throws Exception; void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)throws Exception; void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)throws Exception;&#125; 深入处理流程mappedHandlermappedHandler = getHandler(processedRequest);可以看出getHandler方法就是遍历初始化时已经获取的handlerMappings，如果找到一个HandlerMapping，getHandler方法返回的不为null，那么说明找到了这个mappedHandler，并返回。12345678910111213protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( &quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;); &#125; HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; return null; &#125; getHandler的实现在AbstractHandlerMapping类中，根据request找到Handler和Interceptor，组合成HandlerExecutionChain类型并返回 123456789101112131415161718192021222324@Override public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; Object handler = getHandlerInternal(request); if (handler == null) &#123; handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; // Bean name or resolved handler? if (handler instanceof String) &#123; String handlerName = (String) handler; handler = getApplicationContext().getBean(handlerName); &#125; HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); if (CorsUtils.isCorsRequest(request)) &#123; CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request); CorsConfiguration handlerConfig = getCorsConfiguration(handler, request); CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig); executionChain = getCorsHandlerExecutionChain(request, executionChain, config); &#125; return executionChain; &#125; getHandlerInternal是个接口AbstractHandlerMethodMapping，AbstractUrlHandlerMapping都实现了它。其中AbstractHandlerMethodMapping更常用，注解@RequestMapping的方式就属于它，它将被注解的Method作为handler。1protected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception; lookupHandlerMethod方法来查找url和对应的方法12345678910111213@Overrideprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123; String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); this.mappingRegistry.acquireReadLock(); try &#123; HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null); &#125; finally &#123; this.mappingRegistry.releaseReadLock(); &#125;&#125; 从mappingRegistry中获取匹配路径的mapping，并排序获取最匹配的handlerMethod1234567891011121314151617181920212223242526272829303132333435protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123; List&lt;Match&gt; matches = new ArrayList&lt;Match&gt;(); List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath); if (directPathMatches != null) &#123; addMatchingMappings(directPathMatches, matches, request); &#125; if (matches.isEmpty()) &#123; // No choice but to go through all mappings... addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request); &#125; if (!matches.isEmpty()) &#123; Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request)); Collections.sort(matches, comparator); Match bestMatch = matches.get(0); if (matches.size() &gt; 1) &#123; if (CorsUtils.isPreFlightRequest(request)) &#123; return PREFLIGHT_AMBIGUOUS_MATCH; &#125; Match secondBestMatch = matches.get(1); if (comparator.compare(bestMatch, secondBestMatch) == 0) &#123; Method m1 = bestMatch.handlerMethod.getMethod(); Method m2 = secondBestMatch.handlerMethod.getMethod(); throw new IllegalStateException(&quot;Ambiguous handler methods mapped for HTTP path &apos;&quot; + request.getRequestURL() + &quot;&apos;: &#123;&quot; + m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;); &#125; &#125; handleMatch(bestMatch.mapping, lookupPath, request); return bestMatch.handlerMethod; &#125; else &#123; return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request); &#125;&#125; getHandlerAdapterHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); 同样也是遍历handlerAdapters中所有的adapter，如果和handler的类型匹配，就返回handlerAdapter123456789protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; for (HandlerAdapter ha : this.handlerAdapters) &#123; if (ha.supports(handler)) &#123; return ha; &#125; &#125; throw new ServletException(&quot;No adapter for handler [&quot; + handler + &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;); &#125; applyPreHandlemappedHandler.applyPreHandle(processedRequest, response依次执行interceptor的prehandle方法，如果又一个拦截器返回false就停止 1234567891011121314boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; for (int i = 0; i &lt; interceptors.length; i++) &#123; HandlerInterceptor interceptor = interceptors[i]; if (!interceptor.preHandle(request, response, this.handler)) &#123; triggerAfterCompletion(request, response, null); return false; &#125; this.interceptorIndex = i; &#125; &#125; return true;&#125; handlemv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 这个方法在handlerAdapter的接口中，有几个实现，AbstractHandlerMethodAdapter，AnnotationMethodHandlerAdapter，，，SimpleServletHandlerAdapter：handle方法就是调用Servlet的service((Servlet) handler).service(request, response);。SimpleControllerHandlerAdapter：handle方法本质是执行Controller.handleRequest方法return ((Controller) handler).handleRequest(request, response);HttpRequestHandlerAdapter：((HttpRequestHandler) handler).handleRequest(request, response);AbstractHandlerMethodAdapter：是一个抽象类，handle方法调用handleInternal，handleInternal是一个接口，在实现类RequestMappingHandlerAdapter中实现。关键的地方在于调用invokeHandlerMethod123456789101112@Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; checkRequest(request);//... mav = invokeHandlerMethod(request, response, handlerMethod);//.. prepareResponse(response);//.. return mav;&#125; invokeHandlerMethod就是在执行传入的handler方法123456789protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ......... //执行Controller中的RequestMapping注释的方法 invocableMethod.invokeAndHandle(webRequest, mavContainer); //返回ModelAndView视图 return getModelAndView(mavContainer, modelFactory, webRequest); &#125; applyDefaultViewNameapplyDefaultViewName(processedRequest, mv);很简单，就是设置一下view12345private void applyDefaultViewName(HttpServletRequest request, ModelAndView mv) throws Exception &#123; if (mv != null &amp;&amp; !mv.hasView()) &#123; mv.setViewName(getDefaultViewName(request)); &#125;&#125; applyPostHandle同上applyPreHandle，执行拦截器list中的postHandle方法 processDispatchResult关键就是调用render方法，然后执行拦截器列表中的AfterCompletion方法1234567891011121314151617181920212223private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, request, response); &#125; if (mappedHandler != null) &#123; mappedHandler.triggerAfterCompletion(request, response, null); &#125; &#125; render方法中，关键的一步view.render(mv.getModelInternal(), request, response);这个接口在AbstractView这个抽象类中定义了模版方法 12345678@Override public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response); prepareResponse(request, response); renderMergedOutputModel(mergedModel, getRequestToExpose(request), response); &#125; createMergedOutputModel，关键是这些putAll方法，把静态的attribute和动态值方都放进mergedModel中然后返回，可以看到先put staticAttributes后put model，所以说明动态的值优先级更高可能覆盖静态attribute的值1234567891011121314151617protected Map&lt;String, Object&gt; createMergedOutputModel(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) &#123; ... Map&lt;String, Object&gt; mergedModel = new LinkedHashMap&lt;String, Object&gt;(size); mergedModel.putAll(this.staticAttributes); if (pathVars != null) &#123; mergedModel.putAll(pathVars); &#125; if (model != null) &#123; mergedModel.putAll(model); &#125; // Expose RequestContext? if (this.requestContextAttribute != null) &#123; mergedModel.put(this.requestContextAttribute, createRequestContext(request, response, mergedModel)); &#125; return mergedModel;&#125; prepareResponse就是设置response头 123456protected void prepareResponse(HttpServletRequest request, HttpServletResponse response) &#123; if (generatesDownloadContent()) &#123; response.setHeader(&quot;Pragma&quot;, &quot;private&quot;); response.setHeader(&quot;Cache-Control&quot;, &quot;private, must-revalidate&quot;); &#125; &#125; renderMergedOutputModel又是一个接口protected abstract void renderMergedOutputModel(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception; 有很多实现，对于jsp，在InternalResourceView类中实现 123456789101112131415161718192021222324@Override protected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) &#123; response.setContentType(getContentType()); rd.include(request, response); &#125; else &#123; // Note: The forwarded resource is supposed to determine the content type itself. rd.forward(request, response); &#125; &#125; exposeModelAsRequestAttributes方法就是把model中的值都填到request中123456789101112protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model, HttpServletRequest request) throws Exception &#123; for (Map.Entry&lt;String, Object&gt; entry : model.entrySet()) &#123; String modelName = entry.getKey(); Object modelValue = entry.getValue(); if (modelValue != null) &#123; request.setAttribute(modelName, modelValue); &#125; else &#123; request.removeAttribute(modelName); &#125; &#125;&#125; 如果response已经提交了，included，否则就执行forward到这里，请求处理结束。","tags":[{"name":"java springmvc","slug":"java-springmvc","permalink":"https://zxf14.github.io/tags/java-springmvc/"}]},{"title":"node的事件机制","date":"2017-03-23T14:45:09.000Z","path":"2017/03/23/node的事件机制/","text":"什么是事件循环（event loop）？尽管js是单线程的，事件循环机制，通过在合适的时候把操作交给系统内核，从而允许node执行非阻塞的io操作当操作完成时，内核告知node.js，合适的回调函数会被加入轮询队列，最终被执行。Node.js启动的时候，初始化event loop，处理提供的脚本，脚本中可能调用异步API，调度timers，或者调用process.nextTick()，然后处理event loop 下图是简化的事件循环操作顺序图overview123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ 图中每个box就是一个phase，每个phase有一个先进先出的回调函数的队列，event loop进入了一个phase，就会执行phase中所有的操作，然后执行回调函数，直到队列耗尽了，或者回调函数执行数量到达最大数，接下来就去下一个phase 因为任何一个操作都可能调度更多的操作，而且poll phase中新的事件由内核排队，所以正在轮询的事件在被处理的时候，poll事件们可能会排队。结果：长时间的运行回调函数允许poll phase运行事件比timer的阈值更长。 phase overview 阶段概况 timers：执行由setTimeout() and setInterval()调度的回调函数 I/O callbacks：执行所有的回调函数，除了 close callbacks（由timers，setImmediate（）调度） idle, prepare：内部使用 poll：获取新的io事件，当合适的时候，node会阻塞在这里 check: setImmediate()回调函数会在这里调用 close callbacks: e.g. socket.on(‘close’, …) 每次运行event loop，node检查是否有对任何异步io或者timers的等待，没有就关闭 Phases in Detail（各阶段细述）timerstimers指定阈值（threshold）之后，会执行回调函数，但threshold不是执行回调函数的确切时间（只是最短时间）。timers回调函数一旦可以执行了就会被执行。然而操作系统的调度或者其他的回调函数可能推迟它的执行。由poll phase来控制什么时候timers被执行 123456789101112131415161718var fs = require(&apos;fs&apos;);function someAsyncOperation (callback) &#123; // Assume this takes 95ms to complete fs.readFile(&apos;/path/to/file&apos;, callback);&#125;var timeoutScheduled = Date.now();setTimeout(function () &#123; var delay = Date.now() - timeoutScheduled; console.log(delay + &quot;ms have passed since I was scheduled&quot;);&#125;, 100);// do someAsyncOperation which takes 95 ms to completesomeAsyncOperation(function () &#123; var startCallback = Date.now(); // do something that will take 10ms... while (Date.now() - startCallback &lt; 10) &#123; ; // do nothing &#125;&#125;); 一开始timer被调度，里面的回调函数执行log。然后事件循环进入poll phase，此时队列是空的（因为fs.readFile()没有完成），所以就会等着，直到最早的timer的阈值（100）到时间，等了95 ms（还没到，毕竟定的是100），fs.readFile() 这个时候完成了，所以它的回调函数就回被加poll的队列并且被执行（执行10s），当回调函数完成了，队列又空了，所以，event loop将会看到timer的阈值（100）已经到了，然后回到timers这个phase去执行timers的回调函数，也就是，打印出105秒 为了防止poll phase 独占耗尽 event loop，libuv 也有一个最大值（基于系统），会在超过最大值之前停止轮询更多的事件。 I/O callbacks为系统操作（比如tcp错误类型）执行回调函数当tcp socket尝试连接时接收到ECONNREFUSED，类unix系统将会想报道错误，要会在这个phase排队执行。 pollpoll phase有两个功能 为到了时间的timers执行脚本，然后 处理poll队列的事件 当event loop 进入poll phase且没有timers被调度，下面的事情会发生 poll不空， 通过回调函数队列迭代的执行 poll栈是空的 如果脚本已经被setImmediate()调度，事件循环将会终止poll phase，到check phase去执行那些被调度的脚本 等着回调函数被加进队列，然后立马执行它一旦poll空了，event loop将回检查timers有没有thresholds到了，有的话，wrap back to the timers phase，然后执行timers的回调函数 check 特别的 timer close callbackssetImmediate and setTimeout() 在poll完成以后执行 在最小事件之后执行 执行顺序：依赖于调用的上下文 如果都在main module ，事件会被进程的性能限制（被其他应用影响） not within an I/O cycle：不确定的 within an I/O cycle：immediate总是先（更好）12345678// timeout_vs_immediate.jssetTimeout(function timeout () &#123; console.log(&apos;timeout&apos;);&#125;,0);setImmediate(function immediate () &#123; console.log(&apos;immediate&apos;);&#125;); 1234567891011// timeout_vs_immediate.jsvar fs = require(&apos;fs&apos;)fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;timeout&apos;) &#125;, 0) setImmediate(() =&gt; &#123; console.log(&apos;immediate&apos;) &#125;)&#125;) The Node.js Event Loop, Timers 参考：","tags":[{"name":"node","slug":"node","permalink":"https://zxf14.github.io/tags/node/"}]},{"title":"createServer过程源码解读","date":"2017-03-23T14:44:03.000Z","path":"2017/03/23/createServer过程源码解读/","text":"node的入门就会写这样几行简单的代码，而createServer的过程究竟发生什么 12345678910const http = require(&apos;http&apos;);const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;); res.end(&apos;Hello World\\n&apos;);&#125;);server.listen(() =&gt; &#123; console.log(`Server is running `);&#125;); 问题1：request和response是什么首先在http.js代码中12345const Server = exports.Server = server.Server;exports.createServer = function(requestListener) &#123; return new Server(requestListener);&#125;; createServer做的事情很简单，只是new一个Server的实例，传入回调函数，并返回server const server = require(&#39;_http_server&#39;);可以看到server来自_http_server 123456789101112131415161718192021function Server(requestListener) &#123; if (!(this instanceof Server)) return new Server(requestListener); net.Server.call(this, &#123; allowHalfOpen: true &#125;); if (requestListener) &#123; this.addListener(&apos;request&apos;, requestListener); &#125; this.httpAllowHalfOpen = false; this.addListener(&apos;connection&apos;, connectionListener); this.timeout = 2 * 60 * 1000; this._pendingResponseData = 0;&#125;util.inherits(Server, net.Server);Server.prototype.setTimeout = function(msecs, callback) &#123; this.timeout = msecs; if (callback) this.on(&apos;timeout&apos;, callback); return this;&#125;;exports.Server = Server; Server继承net.Server，且requestListener，作为’request’事件的监听器。 在resOnFinish函数中，self.emit(&#39;request&#39;, req, res);触发了request事件。 res的来源var res = new ServerResponse(req); req的来源 req来自parserOnIncoming的形参；parser.onIncoming = parserOnIncoming.bind(undefined, this, socket, state);而parser来自_http_common的parsers.alloc()。 在方法parserOnHeadersComplete中skipBody = parser.onIncoming(parser.incoming, shouldKeepAlive);传入了request，parser.incoming = new IncomingMessage(parser.socket);说明传入的request是IncomingMessage的实例 IncomingMessage = require(&#39;_http_incoming&#39;).IncomingMessage;_http_incoming中可以看到util.inherits(IncomingMessage, Stream.Readable)；所以IncomingMessage是继承自Stream.Readable 问题2:什么时候执行回调函数 connectionListener中有parser.onIncoming = parserOnIncoming.bind(undefined, this, socket, state); 在server的初始化时 this.on(&#39;request&#39;, requestListener);注册request时加上执行回调操作 this.on(&#39;connection&#39;, connectionListener);注册connection的Listener parserOnIncoming方法中 server.emit(&#39;request&#39;, req, res);发出request；最后在parserOnHeadersComplete方法中调用onIncoming，也就是server里的parserOnIncoming 那么什么时候会发出connection操作呢？ 在net.js中的onconnection方法中self.emit(&#39;connection&#39;, socket);。 在_listen2方法中this._handle.onconnection = onconnection; 在listen里调用listen2self._listen2(address, port, addressType, backlog, fd); Server.prototype.listen = function() 中有对listen方法的调用，也就是说，当server调用listen，会出发connectionListener，进一步触发parserOnIncoming，发出request和response，触发requestListener也就是传入的回调函数","tags":[{"name":"node","slug":"node","permalink":"https://zxf14.github.io/tags/node/"}]},{"title":"延迟加载图片","date":"2017-03-23T14:43:15.000Z","path":"2017/03/23/延迟加载图片/","text":"首先有一个问题 ####src和href属性都用来包含一些外部的实体，那么有什么区别？ src：source用于替代元素（replaced elements简而言之，就是外观和尺寸由外部资源来定义，有img，button，textarea，input，select，object）。href：Hypertext Reference，指定了web资源的定位。因此定义了一个连接或者现在元素之间的关系（比如锚和目的地），或者是当前文档（比如link标签）和属性定位的资源间的关系。所以我们这样写&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;浏览器就能够理解这是一个样式表，而且解析（parse）页面的时候不会中断（但是可能因为浏览器需要依据样式来绘制渲染界面而中断渲染render）。跟把所有css文件倒到style标签不一样。因此也建议用link，不要用 @import来导样式表 。 src属性只是在当前的文本元素定义的地方嵌套了一个资源。例如当浏览器看到&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;页面的下载和处理会被终止，直到浏览器获取，编译，执行了文件。类似于把所有的js文件都倾倒在script标签里。img标签也是类似的。只是一个空标签，内容由src定义，浏览器会暂停加载，直到获取和加载完图像。这也是为什么要把js文件放在body的最后的原因。参考来自http://stackoverflow.com/questions/3395359/difference-between-src-and-href 想到了一个有意思的实现。先不给img标签加上src，直到浏览到了这个位置再加载。对于移动端，还能省流量。 所以来实现一下。第一个问题在于获取图片距离可见范围下边的距离。几个尺寸属性参考http://www.jianshu.com/p/187c0145248c先获取元素距离上边的距离，再获取屏幕可用高度，以及滑动高度。从而得到距离视图下方的高度。 第二个问题在于节流，总不能每滑动一下都执行一遍。有两个实现。同步和异步的方式各实现了。 1234567891011121314151617181920212223handleScroll=(callback)=&gt;&#123; let previousCall=new Date().getTime(); return (e=&gt;&#123; let diff=new Date().getTime()-previousCall if(diff&gt;INTERVAL)&#123; callback.apply(null,arguments); previousCall=new Date().getTime(); &#125; &#125;) &#125;window.addEventListener(&apos;scroll&apos;,handleScroll(checkImgs));//或者let wait=false;ontimeLoad=(e)=&gt;&#123; if(!wait)&#123; wait=true; setTimeout(function()&#123; wait=false; checkImgs(); &#125;,10); &#125;&#125;window.addEventListener(&apos;scroll&apos;,ontimeLoad); 不过第一种的话有个问题，就是不能removeEventListener了 源码：https://github.com/zxf14/font_end_demos/tree/master/defer-img-load","tags":[]},{"title":"Hello World","date":"2017-03-06T02:32:27.000Z","path":"2017/03/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]